<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>VSG Control</title>
    <style>
      body { font-family: Arial, sans-serif; margin: 24px; }
      label { display:block; margin-top:8px }
      input[type="number"], select { width:200px }
      button { margin-top:12px }
    </style>
    </style>
  </head>
  <body>
    <h2>VSG Test Tone</h2>
    <form id="params">
      <label>Mode
        <select id="mode">
          <option value="cw">CW (carrier)</option>
          <option value="iq">IQ Loop (baseband tone)</option>
          <option value="sweep">Sweep (swept carrier)</option>
        </select>
      </label>
      <label>Frequency (Hz)
        <input id="frequency" type="number" value="1000000000" step="1" />
      </label>
      <label>Level (dBm)
        <input id="level" type="number" value="-10" step="0.1" />
      </label>
      <div id="iqParams" style="display:none">
        <label>Sample rate (Hz)
          <input id="sample_rate" type="number" value="1000000" />
        </label>
        <label>Tone freq (Hz)
          <input id="tone_freq" type="number" value="100000" />
        </label>
        <label>IQ length (samples)
          <input id="iq_length" type="number" value="16384" />
        </label>
        <div id="sweepParams" style="display:none; margin-top:8px">
          <label>Sweep bandwidth (Hz)
            <input id="bandwidth" type="number" value="1000000" />
          </label>
          <label>Sweep speed (Hz/s)
            <input id="sweep_speed" type="number" value="1000000" />
          </label>
        </div>
      </div>
      <button id="preview" type="button">Preview Spectrum</button>
      <button id="start">Enable / Start</button>
      <button id="stop" type="button">Disable / Stop</button>
      <div style="margin-top:8px">
        <label>Upload IQ file
          <input id="iqFile" type="file" accept=".iq,.bin" />
        </label>
        <button id="uploadIq" type="button">Upload & Start Preview Loop</button>
        <button id="playUploaded" type="button" disabled>Play Uploaded File</button>
        <button id="stopPreviewBtn" type="button" style="display:none">Stop Preview Loop</button>
        <span id="uploadedPath" style="margin-left:8px"></span>
      </div>
    </form>

    <pre id="status"></pre>

    <h3>Spectrum Preview</h3>
    <p style="color:#666;font-size:12px">Spectrum chart:</p>
    <canvas id="spectrum" width="800" height="360" style="border:2px solid #000;background:#fff;display:block;margin:10px 0"></canvas>
    <div style="margin-top:6px">
      <button id="findPeak" type="button">Find Peak</button>
      <span id="spectrumInfo"></span>
      <span id="peakInfo" style="margin-left:12px;font-weight:bold"></span>
    </div>

    <script>
      const modeEl = document.getElementById('mode');
      const iqParams = document.getElementById('iqParams');
      const status = document.getElementById('status');
      // FFT worker for previews
      let fftWorker = null;
      let lastMag = null;
      let lastFreqs = null;
      try{
        fftWorker = new Worker('/static/fft_worker.js');
        fftWorker.onmessage = function(ev){
          if(ev.data && ev.data.error){ status.textContent = 'Worker error: '+ev.data.error; return; }
          // receive transferable buffers
          try{
            const mag = new Float64Array(ev.data.mag);
            const freqs = new Float64Array(ev.data.freqs);
            lastMag = mag; lastFreqs = freqs;
            drawPlotly(mag, freqs);
            status.textContent = 'Preview ready';
          }catch(err){ status.textContent = 'Worker data error: '+err; console.error(err); }
        };
        fftWorker.onerror = function(ev){
          status.textContent = 'Worker error: ' + ev.message;
          console.error('FFT Worker error:', ev);
        };
        status.textContent = 'Ready (FFT worker initialized)';
      }catch(err){ console.warn('Could not create FFT worker', err); status.textContent = 'Warning: FFT worker not available'; }

      // Initialize mode-dependent UI
      function updateModeUI(){
        iqParams.style.display = (modeEl.value === 'iq' || modeEl.value === 'sweep') ? 'block' : 'none';
        document.getElementById('sweepParams').style.display = modeEl.value === 'sweep' ? 'block' : 'none';
      }
      modeEl.addEventListener('change', updateModeUI);
      
      // Initialize blank spectrum on page load
      function initSpectrum(){
        const canvas = document.getElementById('spectrum');
        console.log('Canvas element:', canvas);
        console.log('Canvas size:', canvas.width, 'x', canvas.height);
        
        const ctx = canvas.getContext('2d');
        if(!ctx){
          status.textContent = 'ERROR: Could not get canvas context';
          return;
        }
        
        // Draw initial empty grid
        drawGrid(ctx, canvas.width, canvas.height);
        status.textContent = 'Canvas spectrum initialized';
      }
      
      function drawGrid(ctx, w, h){
        // Clear canvas
        ctx.fillStyle = '#fff';
        ctx.fillRect(0, 0, w, h);
        
        // Draw axes
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(60, 0);
        ctx.lineTo(60, h);
        ctx.lineTo(w, h);
        ctx.stroke();
        
        // Draw grid lines
        ctx.strokeStyle = '#ddd';
        ctx.lineWidth = 1;
        for(let i = 1; i < 5; i++){
          const x = 60 + (w - 60) * (i / 5);
          ctx.beginPath();
          ctx.moveTo(x, 0);
          ctx.lineTo(x, h);
          ctx.stroke();
          
          const y = h * (i / 5);
          ctx.beginPath();
          ctx.moveTo(60, y);
          ctx.lineTo(w, y);
          ctx.stroke();
        }
        
        // Draw labels
        ctx.fillStyle = '#000';
        ctx.font = '12px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('Frequency (Hz)', (60 + w) / 2, h - 5);
        
        ctx.save();
        ctx.translate(15, h / 2);
        ctx.rotate(-Math.PI / 2);
        ctx.textAlign = 'center';
        ctx.fillText('Relative dB', 0, 0);
        ctx.restore();
      }
      
      // Delay to ensure DOM ready
      setTimeout(initSpectrum, 100);
      updateModeUI();
      
      // Auto-generate initial preview on page load
      window.addEventListener('load', ()=>{
        setTimeout(()=>{
          // Switch to IQ mode for preview
          modeEl.value = 'iq';
          updateModeUI();
          status.textContent = 'Generating initial preview...';
          const sample_rate = Number(document.getElementById('sample_rate').value)||1e6;
          const tone_freq = Number(document.getElementById('tone_freq').value)||1e5;
          let iq_length = Number(document.getElementById('iq_length').value)||16384;
          const MAX_PREVIEW = 8192;
          if (iq_length > MAX_PREVIEW) iq_length = MAX_PREVIEW;
          function nextPow2(v){return 1<<Math.ceil(Math.log2(v));}
          const N = nextPow2(iq_length);
          if(fftWorker){
            fftWorker.postMessage({cmd:'preview', sample_rate: sample_rate, tone_freq: tone_freq, N: N});
          }else{
            status.textContent = 'FFT worker not ready yet';
          }
        }, 500);
      });

      document.getElementById('preview').addEventListener('click', async (e)=>{
        e.preventDefault();
        status.textContent = 'Generating preview...';
        const sample_rate = Number(document.getElementById('sample_rate').value)||1e6;
        const tone_freq = Number(document.getElementById('tone_freq').value)||1e5;
        let iq_length = Number(document.getElementById('iq_length').value)||16384;
        const MAX_PREVIEW = 8192;
        if (iq_length > MAX_PREVIEW) iq_length = MAX_PREVIEW;
        function nextPow2(v){return 1<<Math.ceil(Math.log2(v));}
        const N = nextPow2(iq_length);
        if(fftWorker){
          fftWorker.postMessage({cmd:'preview', sample_rate: sample_rate, tone_freq: tone_freq, N: N});
        }else{
          status.textContent = 'No FFT worker available';
        }
      });

      // FFT and plotting helpers
      function nextPow2(v){ return 1<<Math.ceil(Math.log2(v)); }

      function computeSpectrum(iArr,qArr, fs){
        let N = iArr.length;
        // pad/truncate to power-of-two
        const target = (Math.log2(N)%1===0) ? N : nextPow2(N);
        const re = new Float64Array(target);
        const im = new Float64Array(target);
        for(let k=0;k<target;k++){
          re[k] = (k < N) ? iArr[k] : 0.0;
          im[k] = (k < N) ? qArr[k] : 0.0;
        }
        fft(re,im);
        const mag = new Float64Array(target);
        for(let k=0;k<target;k++) mag[k]=Math.sqrt(re[k]*re[k]+im[k]*im[k]);
        // fftshift and build frequency axis from -fs/2..fs/2
        const half = target/2;
        const out = new Float64Array(target);
        const freqs = new Float64Array(target);
        for(let k=0;k<half;k++){
          out[k]=mag[k+half];
          out[k+half]=mag[k];
        }
        for(let k=0;k<target;k++) freqs[k] = (k - half) * (fs / target);
        return {mag: out, freqs: freqs};
      }

      function drawPlotly(mag, freqs, peakFreq=null, peakMag=null){
        // Use canvas-based drawing instead of Plotly
        drawSpectrum(mag, freqs);
      }

      function drawSpectrum(mag, freqs, peakFreq=null, peakMag=null){
        const canvas = document.getElementById('spectrum');
        const ctx = canvas.getContext('2d');
        const W = canvas.width, H = canvas.height;
        ctx.fillStyle='#fff'; ctx.fillRect(0,0,W,H);
        const N = mag.length;
        // convert to dB full scale (relative)
        let maxv = 1e-12;
        for(let k=0;k<N;k++) if(mag[k]>maxv) maxv=mag[k];
        const db = new Float64Array(N);
        for(let k=0;k<N;k++) db[k]=20*Math.log10(mag[k]/maxv + 1e-12);
        // autoscale: display from (max_dB-80) to max_dB
        const maxdB = Math.max(...db);
        const mindB = maxdB - 80;
        // draw y-axis labels (dB)
        ctx.fillStyle='#000'; ctx.strokeStyle='#ccc'; ctx.font='12px Arial';
        const yTicks = 5;
        for(let t=0;t<=yTicks;t++){
          const val = maxdB + (mindB - maxdB) * (t / yTicks);
          const y = (t / yTicks) * H;
          ctx.fillStyle='#000'; ctx.fillText(val.toFixed(0)+' dB', 4, y+4);
          ctx.beginPath(); ctx.moveTo(60, y); ctx.lineTo(W, y); ctx.strokeStyle='#eee'; ctx.stroke();
        }
        // draw x-axis frequency labels
        const xOffset = 60; // leave space for y labels
        const plotW = W - xOffset - 8;
        ctx.beginPath(); ctx.strokeStyle='#000'; ctx.moveTo(xOffset,0); ctx.lineTo(xOffset,H); ctx.lineTo(W,H); ctx.stroke();
        const xTicks = 8;
        for(let t=0;t<=xTicks;t++){
          const idx = Math.round((t/xTicks)*(N-1));
          const x = xOffset + (t/xTicks)*plotW;
          const f = freqs[idx];
          ctx.fillStyle='#000'; ctx.fillText(formatHz(f), x-20, H-6);
          ctx.beginPath(); ctx.moveTo(x, H-6); ctx.lineTo(x, H-2); ctx.strokeStyle='#000'; ctx.stroke();
        }
        // plot spectrum line
        ctx.strokeStyle='#0077cc'; ctx.lineWidth = 2; ctx.beginPath();
        for(let k=0;k<N;k++){
          const x = xOffset + (k/(N-1))*plotW;
          const y = ((db[k]-maxdB)/(mindB-maxdB)) * H; // 0..H
          const yPos = Math.min(Math.max(y,0),H);
          if(k===0) ctx.moveTo(x,H - yPos); else ctx.lineTo(x,H - yPos);
        }
        ctx.stroke();
        document.getElementById('spectrumInfo').textContent = `Samples: ${N}, BW=${(freqs[N-1]-freqs[0]).toFixed(0)} Hz`;

        // clear previous peak info if no peak
        if(peakFreq === null) document.getElementById('peakInfo').textContent = '';
      }

      function formatHz(f){
        const absf = Math.abs(f);
        if(absf >= 1e9) return (f/1e9).toFixed(3)+' GHz';
        if(absf >= 1e6) return (f/1e6).toFixed(3)+' MHz';
        if(absf >= 1e3) return (f/1e3).toFixed(3)+' kHz';
        return f.toFixed(0)+' Hz';
      }

      document.getElementById('findPeak').addEventListener('click', ()=>{
        if(!lastMag || !lastFreqs){ document.getElementById('peakInfo').textContent = 'No preview data'; return; }
        const mag = lastMag;
        const freqs = lastFreqs;
        let maxIdx = 0, maxV = -1;
        for(let k=0;k<mag.length;k++){ if(mag[k]>maxV){ maxV=mag[k]; maxIdx=k; } }
        const peakFreq = freqs[maxIdx];
        const peakDb = 20*Math.log10(maxV / (Math.max.apply(null, mag) || 1e-12));
        document.getElementById('peakInfo').textContent = `Peak: ${formatHz(peakFreq)}, ${peakDb.toFixed(1)} dB`;
        // Redraw spectrum with peak marker
        drawSpectrum(mag, freqs, peakFreq, maxV);
      });

      // Upload handler
      let uploadedIqPath = null;
      document.getElementById('uploadIq').addEventListener('click', async ()=>{
        const input = document.getElementById('iqFile');
        if(!input.files || input.files.length===0){ alert('Select a file first'); return; }
        const file = input.files[0];
        const fd = new FormData(); fd.append('file', file);
        status.textContent = 'Uploading...';
        try{
          const r = await fetch('/upload_iq', {method:'POST', body: fd});
          const j = await r.json();
          if(j.status==='ok'){
            uploadedIqPath = j.path;
            document.getElementById('uploadedPath').textContent = uploadedIqPath;
            document.getElementById('playUploaded').disabled = false;
            status.textContent = 'Upload complete';
            // start continuous preview loop for uploaded file
            try{
              stopPreviewLoop();
              window.previewOffset = 0;
              window.previewInterval = 0.2; // seconds
              window.previewLength = Math.min(4096, Number(document.getElementById('iq_length').value)||4096);
              window.previewFS = window.iqSampleRate || (Number(document.getElementById('sample_rate').value)||1e6);
              // single-shot first draw
              await fetchAndDrawPreview(uploadedIqPath, window.previewOffset, window.previewLength, window.previewFS);
              // start timer
              window.previewLoopHandle = setInterval(async ()=>{
                try{
                  window.previewOffset = (window.previewOffset + Math.round(window.previewFS * window.previewInterval)) >>> 0;
                  await fetchAndDrawPreview(uploadedIqPath, window.previewOffset, window.previewLength, window.previewFS);
                }catch(err){ console.warn('preview loop error', err); }
              }, Math.round(window.previewInterval*1000));
              status.textContent = 'Upload complete (preview looping)';
            }catch(err){ console.warn('preview error', err); }
          }else{
            status.textContent = 'Upload error: '+(j.message||JSON.stringify(j));
          }
        }catch(err){ status.textContent = 'Upload failed: '+err; }
      });

      document.getElementById('playUploaded').addEventListener('click', async ()=>{
        if(!uploadedIqPath){ alert('No uploaded file'); return; }
        const payload = { path: uploadedIqPath, frequency: Number(document.getElementById('frequency').value)||1e9, level: Number(document.getElementById('level').value)||-10 };
        status.textContent = 'Sending play request...';
        try{
          const r = await fetch('/play_iq_file', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(payload)});
          const j = await r.json();
          status.textContent = JSON.stringify(j);
        }catch(err){ status.textContent = 'Play request failed: '+err; }
      });

      // helper: fetch preview window and draw
      async function fetchAndDrawPreview(path, offset, length, fs){
        const r = await fetch('/preview_iq', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({path: path, length: length, offset: offset})});
        const p = await r.json();
        if(p && p.status === 'ok'){
          const i = p.i, q = p.q;
          const res = computeSpectrum(i, q, fs);
          lastMag = res.mag; lastFreqs = res.freqs;
          drawPlotly(res.mag, res.freqs);
        }
      }

      function stopPreviewLoop(){
        if(window.previewLoopHandle){ clearInterval(window.previewLoopHandle); window.previewLoopHandle = null; }
      }

        // Upload handler
        let uploadedIqPath = null;
        document.getElementById('uploadIq').addEventListener('click', async ()=>{
          const input = document.getElementById('iqFile');
          if(!input.files || input.files.length===0){ alert('Select a file first'); return; }
          const file = input.files[0];
          const fd = new FormData(); fd.append('file', file);
          status.textContent = 'Uploading...';
          try{
            const r = await fetch('/upload_iq', {method:'POST', body: fd});
            const j = await r.json();
            if(j.status==='ok'){
              uploadedIqPath = j.path;
              document.getElementById('uploadedPath').textContent = uploadedIqPath;
              document.getElementById('playUploaded').disabled = false;
              status.textContent = 'Upload complete';
            // start continuous preview loop for uploaded file
            try{
              stopPreviewLoop();
              window.previewOffset = 0;
              window.previewInterval = 0.2; // seconds
              window.previewLength = Math.min(4096, Number(document.getElementById('iq_length').value)||4096);
              window.previewFS = window.iqSampleRate || (Number(document.getElementById('sample_rate').value)||1e6);
              // single-shot first draw
              await fetchAndDrawPreview(uploadedIqPath, window.previewOffset, window.previewLength, window.previewFS);
              // start timer
              window.previewLoopHandle = setInterval(async ()=>{
                try{
                  window.previewOffset = (window.previewOffset + Math.round(window.previewFS * window.previewInterval)) >>> 0;
                  await fetchAndDrawPreview(uploadedIqPath, window.previewOffset, window.previewLength, window.previewFS);
                }catch(err){ console.warn('preview loop error', err); }
              }, Math.round(window.previewInterval*1000));
              status.textContent = 'Upload complete (preview looping)';
              document.getElementById('stopPreviewBtn').style.display = 'inline-block';
            }catch(err){ console.warn('preview error', err); }
            }else{
              status.textContent = 'Upload error: '+(j.message||JSON.stringify(j));
            }
          }catch(err){ status.textContent = 'Upload failed: '+err; }
        });

        document.getElementById('playUploaded').addEventListener('click', async ()=>{
          if(!uploadedIqPath){ alert('No uploaded file'); return; }
          const payload = { path: uploadedIqPath, frequency: Number(document.getElementById('frequency').value)||1e9, level: Number(document.getElementById('level').value)||-10 };
          status.textContent = 'Sending play request...';
          try{
            const r = await fetch('/play_iq_file', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(payload)});
            const j = await r.json();
            status.textContent = JSON.stringify(j);
          }catch(err){ status.textContent = 'Play request failed: '+err; }
        });

        document.getElementById('stopPreviewBtn').addEventListener('click', ()=>{
          stopPreviewLoop();
          document.getElementById('stopPreviewBtn').style.display = 'none';
          status.textContent = 'Preview loop stopped';
        });



      function fft(re,im){
        const n = re.length;
        const bits = Math.log2(n);
        if(Math.floor(bits)!==bits) throw 'FFT size must be power of two';
        for(let i=0;i<n;i++){
          let j=0; for(let b=0;b<bits;b++) j=(j<<1)|((i>>b)&1);
          if(j>i){ let tr=re[i], ti=im[i]; re[i]=re[j]; im[i]=im[j]; re[j]=tr; im[j]=ti; }
        }
        for(let len=2; len<=n; len<<=1){
          const ang = -2*Math.PI/len;
          const wlen_r = Math.cos(ang), wlen_i = Math.sin(ang);
          for(let i=0;i<n;i+=len){
            let wr=1, wi=0;
            for(let j=0;j<len/2;j++){
              const u_r = re[i+j], u_i = im[i+j];
              const v_r = re[i+j+len/2]*wr - im[i+j+len/2]*wi;
              const v_i = re[i+j+len/2]*wi + im[i+j+len/2]*wr;
              re[i+j] = u_r + v_r; im[i+j] = u_i + v_i;
              re[i+j+len/2] = u_r - v_r; im[i+j+len/2] = u_i - v_i;
              const nxt_r = wr*wlen_r - wi*wlen_i;
              const nxt_i = wr*wlen_i + wi*wlen_r;
              wr = nxt_r; wi = nxt_i;
            }
          }
        }
      }

      document.getElementById('start').addEventListener('click', async (e)=>{
        e.preventDefault();
        const payload = {
          mode: document.getElementById('mode').value,
          frequency: Number(document.getElementById('frequency').value),
          level: Number(document.getElementById('level').value),
          sample_rate: Number(document.getElementById('sample_rate').value),
          tone_freq: Number(document.getElementById('tone_freq').value),
          iq_length: Number(document.getElementById('iq_length').value),
          bandwidth: Number(document.getElementById('bandwidth')?.value || 0),
          sweep_speed: Number(document.getElementById('sweep_speed')?.value || 0)
        };
        status.textContent = 'Sending start...';
        try {
          const r = await fetch('/start', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(payload)});
          const j = await r.json();
          status.textContent = JSON.stringify(j, null, 2);
          // if sweep started, begin polling sweep status to animate instantaneous freq
          if(j && j.mode === 'sweep'){
            startSweepPolling();
          }
        } catch (err) { status.textContent = err.toString(); }
      });

      document.getElementById('stop').addEventListener('click', async ()=>{
        status.textContent = 'Stopping...';
        try {
          const r = await fetch('/stop', {method:'POST'});
          const j = await r.json();
          status.textContent = JSON.stringify(j, null, 2);
          stopSweepPolling();
        } catch (err) { status.textContent = err.toString(); }
      });

      // sweep polling
      let sweepPollHandle = null;
      function startSweepPolling(){
        if(sweepPollHandle) return;
        sweepPollHandle = setInterval(async ()=>{
          try{
            const r = await fetch('/sweep_status');
            const j = await r.json();
            if(j && j.frequency!=null){
              // update instantaneous marker on plot
              const f = j.frequency;
              document.getElementById('peakInfo').textContent = `Instant freq: ${formatHz(f)}`;
              // Note: sweep marker display via canvas would require re-rendering on each update
              // For now, just update the frequency text display
            }
          }catch(e){ /* ignore */ }
        }, 200);
      }

      function stopSweepPolling(){
        if(sweepPollHandle){ clearInterval(sweepPollHandle); sweepPollHandle = null; }
      }
    </script>
  </body>
</html>
