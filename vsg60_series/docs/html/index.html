<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>VSG60 API: VSG60 API Programming Manual</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="sh-logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">VSG60 API
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">VSG60 API Programming Manual </div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#autotoc_md0">Examples</a></li>
<li class="level1"><a href="#autotoc_md1">Signal Generation</a></li>
<li class="level1"><a href="#autotoc_md2">Build/Version Notes</a></li>
<li class="level1"><a href="#autotoc_md3">Development Requirements</a></li>
<li class="level1"><a href="#autotoc_md4">I/Q Data and Output Power</a></li>
<li class="level1"><a href="#autotoc_md5">Thread Safety</a></li>
<li class="level1"><a href="#autotoc_md6">Multiple Devices and Multiple Processes</a></li>
<li class="level1"><a href="#autotoc_md7">Status Codes and Error Handling</a></li>
<li class="level1"><a href="#autotoc_md8">Functions</a></li>
<li class="level1"><a href="#autotoc_md9">Linux Notes</a><ul><li class="level2"><a href="#autotoc_md10">Throughput</a></li>
<li class="level2"><a href="#multipleDevicesLinux">Multiple Devices</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md11">Other Programming Languages</a></li>
<li class="level1"><a href="#powerSaving">Power Saving CPU Mode</a></li>
<li class="level1"><a href="#autotoc_md12">Contact Information</a></li>
</ul>
</div>
<div class="textblock"><p ><a class="anchor" id="mainpage"></a></p>
<p >This document is a reference for the VSG60 application programming interface (API). The API provides a set of functions for controlling the <a href="https://signalhound.com/products/vsg60a-6-ghz-vector-signal-generator/">VSG60</a> signal generator.</p>
<h1><a class="anchor" id="autotoc_md0"></a>
Examples</h1>
<p >All code examples are located in the <em>examples/</em> folder in the SDK.</p>
<h1><a class="anchor" id="autotoc_md1"></a>
Signal Generation</h1>
<p >There are two main approaches to generating signals with the VSG60A:</p>
<ul>
<li><a class="el" href="theory_of_operation.html#basigSigGen">Basic Signal Generation</a></li>
<li><a class="el" href="theory_of_operation.html#complexSigGen">Complex Signal Generation (Streaming)</a></li>
</ul>
<h1><a class="anchor" id="autotoc_md2"></a>
Build/Version Notes</h1>
<p >Versions are of the form <b>major.minor.revision</b>.</p>
<p >A <b>major</b> change signifies a significant change in functionality relating to one or more measurements, or the addition of significant functionality. Function prototypes have likely changed.</p>
<p >A <b>minor</b> change signifies additions that may improve existing functionality or fix major bugs but makes no changes that might affect existing user’s measurements. Function prototypes can change but do not change existing parameters meanings.</p>
<p >A <b>revision</b> change signifies minor changes or bug fixes. Function prototypes will not change. Users should be able to update by simply replacing DLL.</p>
<p ><em>Version 1.0.0</em> – Official release</p>
<h1><a class="anchor" id="autotoc_md3"></a>
Development Requirements</h1>
<ul>
<li>Windows development<ul>
<li>Windows 11/10</li>
<li>Windows C/C++ development tools and environment.<ul>
<li>API was compiled using VS2019 and VS2012.<ul>
<li>VS2019/VS2012 C++ redistributables are required.</li>
</ul>
</li>
</ul>
</li>
<li>Library files <a class="el" href="vsg__api_8h.html" title="API functions for the VSG60/VSG200 vector signal generators.">vsg_api.h</a>, vsg_api.lib, and vsg_api.dll.</li>
</ul>
</li>
<li>Linux development<ul>
<li>Ubuntu 22.04/20.04/18.04</li>
<li>Compiled with system GCC compiler on Ubuntu 18.04.</li>
<li>Library files <a class="el" href="vsg__api_8h.html" title="API functions for the VSG60/VSG200 vector signal generators.">vsg_api.h</a>, vsg_api.so</li>
</ul>
</li>
<li>VSG60 device</li>
<li>USB 3.0 connectivity provided through 4th generator or later Intel CPUs.</li>
<li>Dual core Intel i5/i7 processor minimum.</li>
</ul>
<h1><a class="anchor" id="autotoc_md4"></a>
I/Q Data and Output Power</h1>
<p >Waveforms are provided to the API as I/Q samples. I/Q samples should be provided as contiguous interleaved real and imaginary pairs.</p>
<p >Example: [re<sub>1</sub>, im<sub>1</sub>, re<sub>2</sub>, im<sub>2</sub>, …, re<sub>N</sub>, im<sub>N</sub>] would be an array of N I/Q samples, which would equal 2 * N contiguous floating-point values.</p>
<p >Each {re, im} pair represents a single sample. Each real and imaginary value should be a 32-bit floating point value. I/Q samples are provided in full scale. An I/Q magnitude equal to 1.0 will transmit at the output level set by the user.</p>
<p >Magnitude of I/Q sample is calculated as sqrt(I<sup>2</sup> + Q<sup>2</sup>)</p>
<p >To measure the output power of a sample in dBm, use the formula:</p>
<p >Power of I/Q sample = Output power set in <a class="el" href="vsg__api_8h.html#a4f3b9a68cbfabfdd95440d39d0c2158e">vsgSetLevel</a> + 20 * log<sub>10</sub>(magnitude of I/Q sample)</p>
<p >Internally I/Q samples are scaled to achieve the user-selected output power. The default scaling is 0.5 and increases/decreases around this value to digitally scale where the internal amplifier and attenuator cannot. The internal scale can be queried through the API. Because we use a base scale of 0.5, this means magnitudes greater than 1.0 can be tolerated. Clipping occurs when either I or Q value exceeds 1.0 post scaling. The scaling is performed as such.</p>
<p >Scaled I/Q = { real * scaleFactor, imag * scaleFactor }</p>
<p >If you have a waveform with amplitudes much greater than 1.0, it is recommended to query the scale to verify clipping won’t occur or scale the entire waveform and adjust the output power to compensate.</p>
<h1><a class="anchor" id="autotoc_md5"></a>
Thread Safety</h1>
<p >The VSG60 API is not thread safe. A multi-threaded application is free to call the API from any number of threads if the function calls are synchronized (i.e. using a mutex). Not synchronizing your function calls will lead to undefined behavior.</p>
<h1><a class="anchor" id="autotoc_md6"></a>
Multiple Devices and Multiple Processes</h1>
<p >The API can manage multiple devices within one process. In each process the API manages a list of open devices to prevent a process from opening a device more than once. You may open multiple devices by specifying the serial number of the device directly or allowing the API to discover them automatically.</p>
<p >If you wish to use the API in multiple processes, it is the user’s responsibility to manage a list of devices to prevent the possibility of opening a device twice from two different processes. Two processes communicating to the same device will result in undefined behavior. One possible way to manage inter-process information is to use a named mutex on a Windows system.</p>
<p >If you wish to interface multiple devices on Linux, see <a class="el" href="index.html#multipleDevicesLinux">Multiple Devices</a>.</p>
<h1><a class="anchor" id="autotoc_md7"></a>
Status Codes and Error Handling</h1>
<p >All functions return a <a class="el" href="vsg__api_8h.html#a36ee7f829a2d1178df0d58ba9b23f276">VsgStatus</a> error code. <a class="el" href="vsg__api_8h.html#a36ee7f829a2d1178df0d58ba9b23f276">VsgStatus</a> is an enumerated type representing the success of a given function call. The integer values associated with each status provides information about whether a function call succeeded or failed.</p>
<p >An integer value of zero indicates no error or warnings. Negative integer status values indicate errors and positive values represent warnings.</p>
<p >A descriptive string of each status type can be retrieved using the <a class="el" href="vsg__api_8h.html#a1136a2ae452fe9a4bff95e66aa443f46">vsgGetErrorString</a> function.</p>
<h1><a class="anchor" id="autotoc_md8"></a>
Functions</h1>
<p >All functions other than initialization functions take a device handle as the first parameters. This integer is obtained after opening the device through either the <a class="el" href="vsg__api_8h.html#a79c09f779d9844ea2dc28991e7bf9cdd">vsgOpenDevice</a> or <a class="el" href="vsg__api_8h.html#a847bfdd279f21bde259a5f9ea81d85c0">vsgOpenDeviceBySerial</a> function. This handle uniquely identifies the receiver for the duration of the application execution, or until <a class="el" href="vsg__api_8h.html#a14cc8a9ab150038b15af0c47e8f877bb">vsgCloseDevice</a> is called.</p>
<p >Each function returns an error code which can provide warnings or errors related to the execution of the function. There are many cases where you will need to monitor these codes to determine the success or failure of an operation. See a list of common error codes and their descriptions in the Appendix.</p>
<h1><a class="anchor" id="autotoc_md9"></a>
Linux Notes</h1>
<h2><a class="anchor" id="autotoc_md10"></a>
Throughput</h2>
<p >By default, Linux applications cannot increase the priority of individual threads unless ran with elevated privilege (root). On Windows this issue does not exist, and the API will elevate the USB data acquisition threads to a higher priority to ensure USB data loss does not occur. On Linux, the user will need to run their application as root to ensure USB data acquisition is performed at a higher priority.</p>
<p >If this is not done, there is a higher risk of USB data loss.</p>
<p >In our testing, if little additional processing is occurring outside the API, 1 or 2 devices typically will not experience data loss due to this issue. Once the user application increases the processing load or starts performing I/O such as storing data to disk, the occurrence of USB data loss increases and the need to run the application as root increases.</p>
<h2><a class="anchor" id="multipleDevicesLinux"></a>
Multiple Devices</h2>
<p >There are limitations that apply when attempting to use multiple devices on Linux. The maximum amount of memory that can be allocated for USB transfers on Linux is 16MB. A single VSG60A can stay within this limitation, but two devices will exceed this limitation and can cause the API to crash when you do. The USB allocation limit can be changed by writing to the file</p>
<p ><code>/sys/module/usbcore/parameters/usbfs_memory_mb</code></p>
<p >A good value would be <code>N * 16</code> where <code>N</code> is the number of devices you plan on interfacing.</p>
<p >One way to write to this file is with the command</p>
<div class="fragment"><div class="line">sudo sh -c ‘echo 32 &gt; /sys/module/usbcore/parameters/usbfs_memory_mb’</div>
</div><!-- fragment --><p >where 32 can be replaced with any value you wish.</p>
<h1><a class="anchor" id="autotoc_md11"></a>
Other Programming Languages</h1>
<p >The VSG60 interface is C compatible which ensures it is possible to interface the API in most languages that can call C functions. These languages include C++, C#, Python, MATLAB, LabVIEW, Java, etc. Some examples of calling the VSG60 API in these other languages are included in the code examples folder.</p>
<p >The VSG60 API consists of several enumerated(enum) types, which are often used as parameters. These values can be treated as 32-bit integers when callings the API functions from other programming languages. You will need to match the enumerated values defined in the API header file.</p>
<h1><a class="anchor" id="powerSaving"></a>
Power Saving CPU Mode</h1>
<p >Newer CPU models implement efficient power saving techniques that can interfere with and reduce USB bandwidth. If you are using one of these CPU models, you can experience issues with the VSG60 which might appear as data loss when inspecting the output of the VSG60.</p>
<p >We offer 2 potential solutions to this problem:</p>
<p >1) Enable the power saving CPU mode through the API. This has the effect of adding an artificial load to the API to keep the CPU from entering any low power CPU states that might affect the USB throughput. You will see an increase in CPU usage through this method.</p>
<p >2) Disable “C-States” in the BIOS of the PC. This prevents the OS from being able to put the CPU in these low power states which affect USB performance. This will increase power consumption of the PC which will affect battery life but will see lower CPU usage (since power saving CPU mode can be disabled).</p>
<p >The default state of this mode is disabled in the API.</p>
<p >PCs most affected are laptops and ultraportable devices running Windows.</p>
<h1><a class="anchor" id="autotoc_md12"></a>
Contact Information</h1>
<p >For technical questions, email <a href="#" onclick="location.href='mai'+'lto:'+'aj@'+'si'+'gna'+'lh'+'oun'+'d.'+'com'; return false;">aj@signalhound.com</a>.</p>
<p >For sales questions, email <a href="#" onclick="location.href='mai'+'lto:'+'sal'+'es'+'@si'+'gn'+'alh'+'ou'+'nd.'+'co'+'m'; return false;">sales@signalhound.com</a>. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
